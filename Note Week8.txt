第八周
    第十四课：字典树和并查集
        Trie树的基本实现和特性
            字典树（Trie树）
                节点本身不存在完整单词
                从根节点到某一结点，路径上经过的字符链接起来，为该节点对应的字符串
                每个节点的所有子节点路径代表的字符都不相同
            优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高
            英文的话一般是26叉树
                空间消耗相对较大
        并查集（Disjoint Set)
            判断两个群组之间是不是同一个群组
            基本操作：
                makeSet(s): 建立一个新的并查集，其中包含s个单元素集合
                unionSet(x, y)：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并
                find(x): 找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了
            一开始每个都指向自己
            然后开始合并
            一种优化方案：路径压缩
            集合领头元素特点：parent[i] = i

    第十五课：AVL树和红黑树的实现和特性
        AVL树：
            平衡因子 Balance Factor: 左子树的高度减去右子树的高度
            Balance factor = {-1, 0, 1}
        通过旋转来平衡
            子树形态：右右子树 → 左旋
            子树形态：左左子树 → 右旋
            子树形态：左右子树 → 左右旋
            子树形态：右左子树 → 右左旋
        红黑树（近似平衡二叉树）
            能够确保任何一个结点的左右子树的高度差小于两倍
            是满足以下条件的二叉树
            每个结点要么是红色， 要么是黑色
            根节点是黑色
            每个叶结点（NIL结点，空结点）是黑色的
            不能有相邻接的两个红色结点
            从任一结点到其每个叶子的所有路径都包含相同数目的黑色节点

    第十六课：位运算
        左移： <<： 0011 → 0110，1100 → 1000
        右移：>>：0110 → 0011
        按位或： |  :  0011 | 1011 = 1011
        按位与：&:  0011 & 1011 = 0011
        按位取反： ~ : 0011 = 1100
        按位异或： ^: 0011 ^ 1011 = 1000
        X ^ 0 = x
        X ^ 1 = ~x
        X ^ (~x) = 1
        X ^ x = 0
        将x最右边的n位清零：x & ( ~0 << n)
        获取x的第n位值（0或者1）：(x >> n) & 1
        获取x的第n位幂值：x & (1<<n)
        仅将第n位置为1：x|(1<<n)
        仅将第n位置为0：x&(~(1<<n))
        将x最高位至第n位（含）清零：x&((1<<n)-1)

        判断奇偶： (x&1) == 1或者0
        x>>1 → x / 2
        X = x & (x - 1) 清零最低位的1
        X & -x  得到最低位的1
         因为 -x = ~x + 1
