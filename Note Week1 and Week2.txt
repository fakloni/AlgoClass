课前：


面试看题四件套：
1. Clarification：跟面试官走一遍，确定题目的意思
2. Possible solutions
3. Coding
4. Test cases


刷题五毒神掌：
1. 第一遍：5分钟读题+思考，如果没思路就直接看答案
2. 第二遍：马上自己写，闭卷
3. 第三遍：过一天，再做一遍
4. 第四遍：过一周，再做一遍
5. 第五遍：面试前，复习一遍


二叉树遍历－三种：时间复杂度都是O(n)




第一周：


* 第三课：数组链表与跳表
   * 链表查询时O(n)
   * 跳表 (skiplist)
      * 对标的是平衡树（AVL Tree）
      * 只能用于元素有序的情况
      * 插入/删除/搜索 都是 O(log n)
   * 一般做题优化思想：
      * 空间换时间
      * 升维
* 第四课：栈和队列
   * 栈 (zhan) stack 查询是O(n) 增添为O(1)
   * 队列（queue）
      * 优先队列 插入操作是O(1) 取出的时候是O(logn) 按照元素重要性取出
      * 底层实现可以是Heap （堆），BST等..
   * 双端队列（deque）Double-End Queue
      * 队列，可以在前端添加和pop也可以在尾端添加和pop


第二周：


* 第五课：哈希表/映射/集合
   * Hash function / Hash collisions
   * 哈希值最好要分布的比较分散以避免哈希碰撞
* 第六课：数、二叉树、二叉搜索树
   * 中序遍历：升序排列
   * 查询/操作都为 O(logn) 
* 第七课：堆和二叉堆 (Heap)
   * 堆可以迅速的找到一堆数中最大或者最小值 
      * 最大：大根堆，最小：小根堆
      * find-max(min): O(1)
      * Delete-max(min): O(logN)
      * Insert: O(logN) or O(1)
   * 二叉堆：
      * 用完全二叉树来实现
      * 根节点：a[0]
         * 索引为i的左孩子的索引是(2*i+1)
         * 索引为i的右孩子的索引是(2*i+2)
         * 索引为i的父节点是floor((i-1)/2)
      * 插入操作
         * 新元素一律先插入到堆的尾部
         * 依次向上调整整个堆的结构
      * 删除堆顶操作
         * 将堆尾的元素替换到顶部
         * 依次从根部向下调整整个堆的结构（一直到堆尾即可）heapify